---
title: Курс "Основы Linux"
summary: Прохождение курса на платформе Stepik
  - Deep Learning
date: '2024-11-11T00:00:00Z'

# Optional external URL for project (replaces project detail page).
external_link: https://rutube.ru/plst/669682
name: video 

image: 
  image: featured.jpeg
  caption: Course
  focal_point: Smart
  

links:
  - icon: github
    icon_pack: fab
    name: Follow
    url: https://github.com/JaneZhibit
url_code: ''
url_pdf: ''
url_slides: ''
url_video: ''

# Slides (optional).
#   Associate this project with Markdown slides.
#   Simply enter your slide deck's filename without extension.
#   E.g. `slides = "example-slides"` references `content/slides/example-slides.md`.
#   Otherwise, set `slides = ""`.
slides: ""
---

# Цель работы

Прохождение курса "Основы Linux" на платформе Stepik


# Выполнение 

Здесь и далее представлены скриншоты, подтверждающие прохождение курса и демонстрирующие выполнение контрольных заданий

- Чтобы узнать справку по команде, ознакомиться с принципами ее работы надо ввести man и название команды(рис. 001 ).

![1](image/1.jpeg) 001

- Для получения справки по команде ls надо ввести man ls
(рис. 002 ).

![2](image/2.jpeg) 002


- Введя pwd, пользователь получает путь до своего местоположения в каталогах(рис. 003 ).

![3](image/3.jpeg) 003


- Символ / нужен для обозначения начала пути файловой системы(рис. 004 ).

![4](image/4.jpeg) 004


- С помощью утилиты ls можно посмотреть список всего содержимого директории. Другие варианты этим функционалом не обладают(рис. 005 ).

![5](image/5.jpeg) 005


- Параметр -а позволяет увидеть всю информацию, даже скрытых файлов(рис. 006 ).

![6](image/6.jpeg) 006


- Ключ -а позволяет увидеть всю информацию, даже скрытых файлов(рис. 007 ).

![7](image/7.jpeg) 007


- Ключ  -р или же parent позволяет создавать сразу вложенные директории(рис. 008 ).

![8](image/8.jpeg) 008


- Находясь внутри директории, чтобы она создалась раньше необходимо прописать чуть более подробный путь, также используя ключ р(рис. 009 ).

![9](image/9.jpeg) 009


- Утилита file используется для определения типа файлов. Остальные команды нужны для удаления и создания файлов, просмотра содержимого (рис. 010 ).

![10](image/10.jpeg) 010
 
- Утилита touch создает пустой файл, отсальные уоманды этим функционалом не обладают(рис. 011 ).

![11](image/11.jpeg) 011

- Команда rm удаляет файлы навсегда, восстановить их невозможно(рис. 012 ).

![12](image/12.jpeg) 012


- В данной ОС имена файлов зависят от регистра - файлы с маленькой и с большой буквы разные(рис. 013 ).

![13](image/13.jpeg) 013


- Ключ -r recursive необходим для выполнения копирования рекурсивно(рис. 014 ).

![14](image/14.jpeg) 014


- Для полного удаления используем rf - recirsive and force(рис. 015 ).

![15](image/15.jpeg) 015


- Вывести начальные строки позволяет комадна head. Это возможно сделать и по-другому, но с уточнениями(рис. 016 ).

![16](image/16.jpeg) 016


- Вывести конечные строки позволяет комадна head. Это возможно сделать и по-другому, но с более подробным синтаксисом(рис. 017 ).

![17](image/17.jpeg) 017


- Просматривать файлы, разделив их на страницы, можно командами more и less(рис. 018 ).

![18](image/18.jpeg) 018


- Вывод последних 2х строк возможен командой tail с ключом -2 и названием файла(рис. 019 ).

![19](image/19.jpeg) 019


- Для хранения своих персональных данных существует директория home(рис. 020 ).

![20](image/20.jpeg) 020

- Имена скрытых файлов всегда начинаются именно с символа точки(рис. 021 ).

![21](image/21.jpeg) 021  


- Для съемных устройств точкой монтирования является директория media(рис. 022 ).

![22](image/22.jpeg)


- Файлы конфигурации хранятся в etc(рис. 023 ).

![23](image/23.jpeg) 023


- В свою очередь файлы устройства находятся в dev - device(рис. 024 ).

![24](image/24.jpeg) 024


- Центральное хранилище журналов - var/log(рис. 025 ).

![25](image/25.jpeg) 025  


- Из представленных вариантов кэшированные данные приложений могут содержаться в var/cache(рис. 026 ).

![26](image/26.jpeg) 026  


- Данная команда передает 4 аргумента -  4 пары одинарных кавычек(рис. 027 ).

![27](image/27.jpeg) 027  


- Количество пробелов сохраниться только если передавать всю строку целиком, с помощью одинарных или двойных кавычек(рис. 028 ).

![28](image/28.jpeg) 028  


- Определить данное различие команд можно с помощью type(рис. 029 ).

![29](image/29.jpeg) 029  


- Для такого типа поиска используется команда which(рис. 030 ).

![30](image/30.jpeg) 030  


- Чтобы создать псевдоним используем alias и соответственно название и команду(рис. 031 ).

![31](image/31.jpeg) 031  

- Из перечисленных команд встроеннымиявляются - alias, echo. Остальные к ним не относятся(рис. 032 ).

![32](image/32.jpeg) 032  

- Внешними являются все представленные команды кроме alias. Обратим внимание, что команда может одновременно относиться к обоим типам(рис. 033 ).

![33](image/33.jpeg) 033  

- Рассмотрим соотношение бинарных файлов и директорий
alias - 

route - sbin

rm - bin

tac - usr/bin
(рис. 034 ).

![34](image/34.jpeg) 034  

- Для последовательного выполнения команд, заданых одной строкой использюется знак ;(рис. 035 ).

![35](image/35.jpeg) 035  

- При остутсствие необходимости ожидания заврешения работы  можно использовать &  и сразу ввводить новую команду(рис. 036 ).

![36](image/36.jpeg) 036  

- Логическое и - &&

Логическо или - ||(рис. 037 ).

![37](image/37.jpeg) 037  

- '#' - символ для последующего написания комментариев(рис. 038 ).

![38](image/38.jpeg) 038  

- При необходимости вывод символа без его свойств используется обратный слэш - \(рис. 039 ).

![39](image/39.jpeg) 039  


- Узнать текущее местоположение и содержимое кталога можно введя  pwd; ls(рис. 040 ).

![40](image/40.jpeg) 040  

- Данная строка удаляет файл и сообщает, успешно или нет выполнена команда(рис. 041 ).

![41](image/41.jpeg) 041  


- Переменные в оболочке обозначаются символом доллара $(рис. 042 ).

![42](image/42.jpeg) 042  


- Присвоение значения происходит так: $Имя=Значение. Обратим внимание, на отсутствие пробелов(рис. 043 ).

![43](image/43.jpeg) 043  



- Список переменных можно увидеть с помощью команд set и env(рис. 044 ).

![44](image/44.jpeg) 044  



- В выводе название переменной указано в кавычках, следовательно результатом будет просто название, а не значение(рис. 045 ).

![45](image/45.jpeg) 045  



- Здесь используются двойные кавычки, что дает компьютеру понять, что вывести надо значение переменной(рис. 046 ).

![46](image/46.jpeg) 046  



- Для удаления переменной окружения использутеся unset(рис. 047 ).

![47](image/47.jpeg) 047  


- Это делает переменная $PATH(рис. 048 ).

![48](image/48.jpeg) 048  



Данное действие  можно осуществить с помощью доллара и скобок или же одинарных кавычек(рис. 049 ).

![49](image/49.jpeg) 049  


- Многоуровневое встраивание делается за счет символа доллара и кавычек(рис. 050 ).

![50](image/50.jpeg) 050  


- На скриншоте видно правильное соотношение(рис. 051 ).

![51](image/51.jpeg) 051  


- Пробел позволяет не сохранять команду в истории(рис. 052 ).

![52](image/52.jpeg) 052  


- Сохранить определнное количество команд в истории возможно указав размер командой HISTSIZE(рис. 053 ).

![53](image/53.jpeg) 053  


- Соотношение потоков ввода-вывода и номеров представлено ниже(рис. 054 ).

![54](image/54.jpeg) 054  


- Содержимое будет удалено при использовании > (рис. 055 ).

![55](image/55.jpeg) 055  


- Сообщение не будет выводиться при перенаправлении потоков - в 1м и последнем случаях(рис. 056 ).

![56](image/56.jpeg) 056  


- Активирование режима происходит командами set -o noclobber и  set -C(рис. 057 ).

![57](image/57.jpeg) 057  


- Да, параметр активирован, перезапись предотвращается(рис. 058 ).

![58](image/58.jpeg) 058  


- Два вывода имеется только у командаы tee(рис. 059 ).

![59](image/59.jpeg) 059  



- Команды и их функционал представлены на скриншоте (рис. 060 ).

![60](image/60.jpeg) 060  


- В пропуск, для подсчета строк, необходимо добавть wc(рис. 061 ).

![61](image/61.jpeg) 061  


- Для сортировки по второму столбцу используем ключ -k 2(рис. 062 ).

![62](image/62.jpeg) 062  


- На скриншоте показано праавильное соотношение команд и того, для чего и когда они применяются(рис. 063 ).

![63](image/63.jpeg) 063  


- Для того, чтобы созданный файл можно было найти с помощью locate необходимо обновить базу данных - updatedb(рис. 064 ).

![64](image/64.jpeg) 064  


- Найти все директории можно ключом -d. Также необходимо указать сам шаблон для поиска - "foo" (рис. 065 ).

![65](image/65.jpeg) 065  


- Поиск файлов рсуществялется с помощью указания f  и шаблона '*bar'(рис. 066 ).

![66](image/66.jpeg) 066  


- Для поиска и копирования файлов введем катаолг /etc, шаблон файлов и пропишем копирование(рис. 067 ).

![67](image/67.jpeg) 067  


- На скриншоте представлено соответсвие сокращений с их расшифровками(рис. 068 ).

![68](image/68.jpeg) 068  


- При таком выводе могли использоваться только 2 и 6 команды с ключом G и E и таким синтаксисом(рис. 069 ).

![69](image/69.jpeg) 069  


- Из Бельгии найти спортсменов можно используя ключ -i, то есть не учитывая регистр(рис. 070 ).

![70](image/70.jpeg) 070  




- Правильное соотношение маски с выводом представлено ниже(рис. 071 ).

![71](image/71.jpeg) 071  

- Данный вывод возможен только при вводе команд 2 и 6 - обязательно не учитывается регистр и соответсвующий синтаксис(рис. 072 ).

![72](image/72.jpeg) 072  



- Здесь  происходит замена "За" на "При", получается Приморский(рис. 073 ).

![73](image/73.jpeg) 073  



- В следующем примере заменилось "Заморский" на "Заморить", следовательно заменили "ский" на "ить"(рис. 074 ).

![74](image/74.jpeg) 074  



- В этом случае символы && дублирует текст перед этим - получается послепослезавтра (рис. 075 ).

![75](image/75.jpeg) 075  



- Здесь происходит перестановка числа и месяца, также меняется символточки на слэш(рис. 076 ).

![76](image/76.jpeg) 076  



- Клавиша esc предназначена для перевода редактора в режим ввода команд, а вот для ввода текста используется insert(рис. 077 ).

![77](image/77.jpeg) 077  



- Перейти в режим ввода текста можно командами a, i, o(рис. 078 ).

![78](image/78.jpeg) 078  



- w - write, сохранение, q - quit, завершение, также это можно сделать командой ZZ (рис. 079 ).

![79](image/79.jpeg) 079  


- Соотношение команд и их функцинала представлено на скриншоте(рис. 080 ).

![80](image/80.jpeg) 080  



- yyp - комбинация для создания дупликата строки(рис. 081 ).

![81](image/81.jpeg) 081  




- Для смены строк местами необходимо использовать сочетание ddp(рис. 082 ).

![82](image/82.jpeg) 082  


- Для выполнения этого действия надо сначала указать номера строк, затем где меняем и на что меняем(рис. 083 ).

![83](image/83.jpeg) 083  



- she-bang - последовательность символом для запуска сценариев в оболочке(рис. 084 ).

![84](image/84.jpeg) 084  



- Примеры she-bang должны включать в себя #! bin и оболочку - bash, csh и другие(рис. 085 ).

![85](image/85.jpeg) 085  



- Для запуска в оболочке Korn shell необходимо написать ее сокращение - ksh(рис. 086 ).

![86](image/86.jpeg) 086  



- На скриншоте прдеставлен написанный пример программы, читающей и выводящей различные переменные(рис. 087 ).

![87](image/87.jpeg) 087  



- Команде test эквивалентны символы [] (рис. 088 ).

![88](image/88.jpeg) 088  



- На скриншоте представлено верное соотношение синтаксиса команды с тем, что она делает(рис. 089 ).

![89](image/89.jpeg) 089  



- Проанализировав представленный код, можно понять, что выводиться будет "мало" , так как выполнятеся условия else(11 меньше 42)(рис. 090 ).

![90](image/90.jpeg) 090  

- При исполнении скрипта выводится 1: 4 - 3, так как выполняется первое условие(рис. 091 ).

![91](image/91.jpeg) 091  


- Для последовательного вывода чисел необходимо просто прописать условие - 10..1(рис. 092 ).

![92](image/92.jpeg) 092  



- Здесь также необходимо только прописать условие "пока i меньше или равно 11"(рис. 093 ).

![93](image/93.jpeg) 093  



- Аналогично прописываем условия соотаетсвенно заданию - "пока не станет меньше 3"(рис. 094 ).

![94](image/94.jpeg) 094  



- Напишем скрипт, считывающий переменные и выводяший сумму от a до  b(рис. 095 ).

![95](image/95.jpeg) 095  



- На скриншоте представлено соотношение символа $ и доп символов с их обозначениями - номерами аргументов, их количеством и тд(рис. 096 ).

![96](image/96.jpeg) 096  


- Для получения параметров сценариев существует специальная функция  getopts(рис. 097 ).

![97](image/97.jpeg) 097  



- В свою очередь параметры функционирования оболочки можно получить с  помощью shopt(рис. 098 ).

![98](image/98.jpeg) 098  



- Последовательный вывод аргументов с предварительной проверкой аргументов осуществляется циклом while  и передачей туда аргументов(рис. 099 ).

![99](image/99.jpeg) 099  


- Команда eval - evaluate позволяет интерпретировать аргументы в директивы сценария оболочки(рис. 100 ).

![100](image/100.jpeg) 100  

- Наличие двойных скобок позволяет сравнивать числовые значения(рис. 101 ).
 
![101](image/101.jpeg) 101  



- Вычисления значений в оболочке происходят командой let(рис. 102 ).

![102](image/102.jpeg) 102  


- За имя учетной записи отвечает команда who am i(whoami), другие вариации невозможны(рис. 103 ).

![103](image/103.jpeg) 103  


- Входящих в системы, напротив, можно узнать командами who и w(рис. 104 ).

![104](image/104.jpeg) 104  


- id - утилита для подробной информации об идентификаторе, группах и тд пользователя(рис. 105 ).

![105](image/105.jpeg) 105  


- Запуск оболочки от лица суперпользователя осуществялется командой su (рис. 106 ).

![106](image/106.jpeg) 106  


- Команда по умолчанию не меняет переменные окружения оболочки(рис. 107 ).

![107](image/107.jpeg) 107  


- Команда su - позволяет работать в окружении оболочки целевого пользователя, а не обязательно исходного, как по умолчанию(рис. 108 ).

![108](image/108.jpeg) 108  


- Не зная пароля, но введя команду sudo, можно выполнить команду от имени другого пользователя(рис. 109 ).

![109](image/109.jpeg) 109  


- По умолчанию пароль от root не задается, это можно сделать самостоятельно в настройках(рис. 110 ).

![110](image/110.jpeg) 110  

- Вся локальная база даннных учетных записей нахоится в директории   passwd(рис. 111 ).

![111](image/111.jpeg) 111  

- Больше всего полномочий иммет пользователь root или же суперпользователь(рис. 112 ).

![112](image/112.jpeg) 112  


- На скриншоте представлено верное соотношения утилит и функций(рис. 113 ).

![113](image/113.jpeg) 113  


- Директория skel - директория-шаблон домашней директории(рис. 114 ).

![114](image/114.jpeg) 114  


- Именно в зашифрованном виде пароли хранятся в каталогу shadow(рис. 115 ).

![115](image/115.jpeg) 115  


- Утилиты openssl и passwd позволяют шифровать фразу для создания пароля, друние утилиты для этого не подходят(рис. 116 ).

![116](image/116.jpeg) 116  


- Данная утилита обладает большим функционалом, в частности она позволяет устанавливать различные даты и сроки действия паролей(рис. 117 ).

![117](image/117.jpeg) 117  


- Наличие ! перед кэшем свидельствует о блокировке записи (рис. 118 ).

![118](image/118.jpeg) 118  


- Необходим файл, находящийся в каталоге etc(рис. 119 ).

![119](image/119.jpeg) 119  


- В целом, подходят все представленные варианты(рис. 120 ).

![120](image/120.jpeg) 120  

- Название утилиты gropadd указывает на то, что она создает новую группу(рис. 121 ).

![121](image/121.jpeg) 121  


- Принадлежность пользователей к группам содержится в папке group(рис. 122 ).

![122](image/122.jpeg) 122  


- Groups - команда, показывающая принадлежность пользователя к группам(рис. 123 ).

![123](image/123.jpeg) 123  


- Usermod - команда, позволящая изменить членство пользователя. Остальные команды были рассмотрены ранее(groupmod - изменение имени)(рис. 124 ).

![124](image/124.jpeg) 124  


- Для этого существует ключ а(рис. 125 ).

![125](image/125.jpeg) 125  


- Groupmod - утилита для изменения названия, аналогична usermod(рис. 126 ).

![126](image/126.jpeg) 126  


- А вот утилита chown позволяет менять и имя группы, и пользователя владеющими файлом(рис. 127 ).

![127](image/127.jpeg) 127  


- Chgrp - изменение имени группы, владеющей файлом(рис. 128 ).

![128](image/128.jpeg) 128  


- Утилита chmod  отвечает за права доступа к файлу(не путать с chown(рис. 129 ).

![129](image/129.jpeg) 129  


- Заменить имя пользователя позволит команда chown с указанием на кого менять и каталога(рис. 130 ).

![130](image/130.jpeg) 130  


- Для замены группы воспользуемся командой chgrp, остальное аналогичнопримеру выше(рис. 131 ).

![131](image/131.jpeg) 131  

- Для замены и группы и владельца необходима команда chown и запись через двоеточие(рис. 132 ).

![132](image/132.jpeg) 132  

- Соответсвие обозначений и расшифровки представлено ниже(рис. 133 ).

![133](image/133.jpeg) 133  

- Ниже представлено сопоставление прав доступа и их сокращений(рис. 134 ).

![134](image/134.jpeg) 134  

- Для каждого пользователя отведено по ___, соответственно владельцу доступны вход и чтение, остальным только доступ(рис. 135 ).

![135](image/135.jpeg) 135  

- Основываясь на команде, можно понять, что у владельца есть право на все, его группа имеет право на чтение и исполнение, у остальных пользователей только чтение, также, по дальнейшей информации, видно, что это файл(рис. 136 ).

![136](image/136.jpeg) 136  

- Основываясь на таблице соответствий легко перевести права в виде строки в численное значение - 755(рис. 137 ).

![137](image/137.jpeg) 137  

- (рис. 138 ).

![138](image/137.jpeg) 138  

- Аналогично получим 740((рис. 139 ).

![139](image/139.jpeg) 139  



- Переведем в двоичную систему - пропуск=ноль, буква=1(рис. 140 ).

![140](image/140.jpeg) 140  

- Функция sticky заключается в предотвращении удаления файлов пользователей не владельцев(рис. 141 ).

![141](image/141.jpeg) 141  


- Описание использование бита описано в последнем варианте(рис. 142 ).

![142](image/142.jpeg) 142  


- Описание использование бита описано во втором варианте - используется для повышения прав(рис. 143 ).

![143](image/143.jpeg) 143  


- Утилита getfacl позволяет читать списки контроля доступа, а вот модификации и запись осуществить не получится(рис. 144 ).

![144](image/144.jpeg) 144  



- Зато следующая утилита как ра-таки позволяет выполнить все эти операции - запись, удаление и модификация(рис. 145 ).

![145](image/145.jpeg) 145  



- Inode - сьруктура данных, содержащая метаданные файла(рис. 146 ).

![146](image/146.jpeg) 146  



- ls -li  - команда для просмотра идентификаторов структуры(рис. 147 ).

![147](image/147.jpeg) 147  



- Жесткие ссылки ограничены своими разделами дисков, имеют те же права, что и файл и связаны с inode. Права доступа имеют значение,они также указывают на структуры inode и не могут указывать на файлы из других систем (рис. 148 ).

![148](image/148.jpeg) 148  



- Симвоилческие ссылки противоположны жестким по своей сути(рис. 149 ).

![149](image/149.jpeg) 149  


- Ниже представлено соотношение файлов в каталогах с их содержимым(рис. 150 ).

![150](image/150.jpeg) 150  


- Ниже представлено верное соотношение утилит с их значением(рис. 151 ).

![151](image/151.jpeg) 151  


Завершение курса

К сожалению, в процессе выполнения курса пришлось столкнуться с проблемой невозможности получения баллов за некоторые задания в связи с настройками авторов, тем не менее пройдено 92% материала и выполнены все задания.

(рис. 152 ).

![152](image/152.jpeg) 152  




# Выводы

В отчете представлено прохождение курса "Основы Linux" на платформе Stepik. В ходе работы былы получены знания по работе с операционной системой, изучены различные тонкости и нюансы, написано несколько скриптов и выполнено определенное количество заданий


